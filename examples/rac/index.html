<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Hardcaml On The Web</title>
        <script type="text/javascript" defer="defer" src="hardcaml_app.bc.js"></script>
        <meta name="description" content="Hardcaml Web Application">
        <script src="https://mathscribe.com/mathscribe/jquery-1.4.3.min.js"></script>
        <script src="https://mathscribe.com/mathscribe/jqmath-etc-0.4.6.min.js"></script>
    </head>
    <body>
        <h1>Rom Accumulator</h1>
        <p>The distributed arithmetic ROM accumulator is a way of computing the following function,
            given a small number of static coefficients.

            $$∑↙{i=0}↖{n-1} c_{i}.x_{i}$$
        </p>
        <p>The basic idea is an extension of multiplying by iterating over the bits of one
           of the operands.  For example, given $a$ and $b=13=1101$ we can multiply
           by adding and shifting at the locations of $b$ which are one.</p>

        $$a * b = a + 2^2a + 2^3a$$

        <p> This can also be done in a bitserial fashion starting at the most significant
            bit of $b$ and multiplying the result by 2 on each iteration.</p>

        <p>The rom-accumulator extends this idea by taking 1 bit from multiple input values per
            iteration and using them to address into a ROM formed from the coefficients as
            follows.<p>

        <table>
            <tr> <th>input bits</th> <th>rom value</th> </tr>
            <tr> <td>000</td> <td> $0$           </td> </tr>
            <tr> <td>001</td> <td> $c_{0}$       </td> </tr>
            <tr> <td>010</td> <td> $c_{1}$       </td> </tr>
            <tr> <td>011</td> <td> $c_{1}+c_{0}$ </td> </tr>
            <tr> <td>100</td> <td> $c_{2}$             </td> </tr>
            <tr> <td>101</td> <td> $c_{2}+c_{0}$       </td> </tr>
            <tr> <td>110</td> <td> $c_{2}+c_{1}$       </td> </tr>
            <tr> <td>111</td> <td> $c_{2}+c_{1}+c_{0}$ </td> </tr>
        </table>

        <p>The value from the ROM is added to the accumulated result.</p>

        <p>By starting at the msb and shifting up each iteration we are able to accumulate an
           exact result.  It is also possible start at the bottom and shift downwards
           instead - usually keeping some extra fractional precision within the accumulator.
           This is useful when working on approximations of real numbers and is demonstrated
           in the simulation below..</p>
        <div id="hardcaml_app"></div>
    </body>
</html>
